rect(i, 0, i + 1, 1, col = "purple", border = NA)
}
if (is.null(last_state)){
last_state <- stateszika[i]
}
else if (last_state != stateszika[i]){
counter_zika <- counter_zika + 1
last_state <- stateszika[i]
}
}
print(counter_zika)
mn = "Dengue nucleotide predicted states"
xlb = "Nucleotide position"
ylb = ""
plot(1:length(statesdengue),ylim = c(0,1), main = mn, xlab = xlb, ylab = ylb, yaxt = "n")
last_state <- NULL
counter_dengue <- 0
for (i in 1:length(statesdengue)) {
if (statesdengue[i] == "GC"){
rect(i, 0, i + 1, 1, col = "gold", border = NA)
}
else{
rect(i, 0, i + 1, 1, col = "purple", border = NA)
}
if (is.null(last_state)){
last_state <- statesdengue[i]
}
else if (last_state != statesdengue[i]){
counter_dengue <- counter_dengue + 1
last_state <- statesdengue[i]
}
}
print(counter_dengue)
if (counter_dengue > counter_zika){
print("Dengue sequence has more changing points.")
} else {
print("Zika sequence has more changing points")
}
## El plot está a lo cutre programado, pero funciona.
## Se puede juntar todo el código de cada virus en un único loop
window=100
chunks <- length(zika)%/%window
zika_gcs <- numeric(chunks)
zika_cct <- vector("logical", chunks)
for (i in 1:chunks){
a<-(i-1)*window+1; b <- a+window-1
zika_gcs[i] <- GC(zika[a:b])
zika_cct[i] <- count(zika[a:b],3)["cct"] > 0
}
# Dengue
chunks <- length(dengue)%/%window
dengue_gcs <- numeric(chunks)
dengue_cct <- vector("logical", chunks)
for (i in 1:chunks){
a<-(i-1)*window+1; b <- a+window-1
dengue_gcs[i] <- GC(dengue[a:b])
dengue_cct[i] <- count(dengue[a:b],3)["cct"] > 0
}
zika_df <- as.data.frame(cbind(zika_gcs, zika_cct))
zika_logit <- glm(zika_cct~zika_gcs, data=zika_df, family = "binomial")
summary(zika_logit)
dengue_logit <- glm(dengue_cct~dengue_gcs, family = "binomial")
summary(dengue_logit)
test <- as.data.frame(matrix(c(0.5), dimnames = as.list(c("j","zika_gcs"))))
print(predict(zika_logit, test, type= "response"))
test <- as.data.frame(matrix(c(0.5), dimnames = as.list(c("j","dengue_gcs"))))
print(predict(dengue_logit, test, type= "response"))
# Download viruses sequences:
# install.packages("HMM")
# install.packages(("HiddenMarkov"))
library(seqinr)
library(HiddenMarkov)
library(HMM)
zika <- read.fasta(file="/home/xoel/github/Stochastic/zika.fasta")[[1]]
dengue <- read.fasta(file="/home/xoel/github/Stochastic/dengue.fasta")[[1]]
model <- initHMM(States=c("AT", "GC"), Symbols=c("a","c","g","t"), transProbs = matrix(c(.7,.3,.3,.7),2), emissionProbs = matrix(c(0.329,0.301,0.159,0.211,0.181,0.313,0.307,0.199), 2, byrow=TRUE))
stateszika <- viterbi(model, zika)
statesdengue <- viterbi(model, dengue)
mn = "Zika nucleotide predicted states"
xlb = "Nucleotide position"
ylb = ""
plot(1:length(stateszika),ylim = c(0,1), main = mn, xlab = xlb, ylab = ylb, yaxt = "n")
last_state <- NULL
counter_zika <- 0
for (i in 1:length(stateszika)) {
if (stateszika[i] == "GC"){
rect(i, 0, i + 1, 1, col = "gold", border = NA)
}
else{
rect(i, 0, i + 1, 1, col = "purple", border = NA)
}
if (is.null(last_state)){
last_state <- stateszika[i]
}
else if (last_state != stateszika[i]){
counter_zika <- counter_zika + 1
last_state <- stateszika[i]
}
}
print(counter_zika)
mn = "Dengue nucleotide predicted states"
xlb = "Nucleotide position"
ylb = ""
plot(1:length(statesdengue),ylim = c(0,1), main = mn, xlab = xlb, ylab = ylb, yaxt = "n")
last_state <- NULL
counter_dengue <- 0
for (i in 1:length(statesdengue)) {
if (statesdengue[i] == "GC"){
rect(i, 0, i + 1, 1, col = "gold", border = NA)
}
else{
rect(i, 0, i + 1, 1, col = "purple", border = NA)
}
if (is.null(last_state)){
last_state <- statesdengue[i]
}
else if (last_state != statesdengue[i]){
counter_dengue <- counter_dengue + 1
last_state <- statesdengue[i]
}
}
print(counter_dengue)
if (counter_dengue > counter_zika){
print("Dengue sequence has more changing points.")
} else {
print("Zika sequence has more changing points")
}
## El plot está a lo cutre programado, pero funciona.
## Se puede juntar todo el código de cada virus en un único loop
window=100
chunks <- length(zika)%/%window
zika_gcs <- numeric(chunks)
zika_cct <- vector("logical", chunks)
for (i in 1:chunks){
a<-(i-1)*window+1; b <- a+window-1
zika_gcs[i] <- GC(zika[a:b])
zika_cct[i] <- count(zika[a:b],3)["cct"] > 0
}
print(mean(zika_gcs))
# Dengue
chunks <- length(dengue)%/%window
dengue_gcs <- numeric(chunks)
dengue_cct <- vector("logical", chunks)
for (i in 1:chunks){
a<-(i-1)*window+1; b <- a+window-1
dengue_gcs[i] <- GC(dengue[a:b])
dengue_cct[i] <- count(dengue[a:b],3)["cct"] > 0
}
print(mean(dengue_gcs))
zika_df <- as.data.frame(cbind(zika_gcs, zika_cct))
zika_logit <- glm(zika_cct~zika_gcs, data=zika_df, family = "binomial")
summary(zika_logit)
dengue_logit <- glm(dengue_cct~dengue_gcs, family = "binomial")
summary(dengue_logit)
test <- as.data.frame(matrix(c(0.5), dimnames = as.list(c("zika","zika_gcs"))))
print(predict(zika_logit, test, type= "response"))
test <- as.data.frame(matrix(c(0.5), dimnames = as.list(c("dengue","dengue_gcs"))))
print(predict(dengue_logit, test, type= "response"))
# Step 1. Simulate a poisson distribution:
sample <- rpois(1000, 20.5)
# Step 2. Define a function that computes the probability of the data belonging to a poisson distribution of a given lambda:
log_density <- function(data, lambda){
log_d <- dpois(data, lambda, log=TRUE)  # Stores the probability of all data points in a vector
return(sum(log_d))  # Returns the sum of such vector
}
# Step 3. Since R does not support minimization, we define another function that returns the negative result of log_density:
min_to_max <- function(data, lambda){
return(-log_density(data, lambda))
}
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max)
# Step 1. Simulate a poisson distribution:
sample <- rpois(1000, 20.5)
# Step 2. Define a function that computes the probability of the data belonging to a poisson distribution of a given lambda:
log_density <- function(data, lambda){
log_d <- dpois(data, lambda, log=TRUE)  # Stores the probability of all data points in a vector
return(sum(log_d))  # Returns the sum of such vector
}
# Step 3. Since R does not support minimization, we define another function that returns the negative result of log_density:
min_to_max <- function(data, lambda){
return(-log_density(data, lambda))
}
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max, p=20)
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max(sample), p=20)
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max(data=sample), p=20)
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max, p=20)
# Step 1. Simulate a poisson distribution:
sample <- rpois(1000, 20.5)
# Step 2. Define a function that computes the probability of the data belonging to a poisson distribution of a given lambda:
log_density <- function(data, l){
log_d <- dpois(data, lambda=l, log=TRUE)  # Stores the probability of all data points in a vector
return(sum(log_d))  # Returns the sum of such vector
}
# Step 3. Since R does not support minimization, we define another function that returns the negative result of log_density:
min_to_max <- function(l){
return(-log_density(sample, l))
}
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max, p=20)
# Step 1. Simulate a poisson distribution:
sample <- rpois(1000, 20.5)
# Step 2. Define a function that computes the probability of the data belonging to a poisson distribution of a given lambda:
log_density <- function(data, lambda){
log_d <- dpois(data, lambda=lambda, log=TRUE)  # Stores the probability of all data points in a vector
return(sum(log_d))  # Returns the sum of such vector
}
# Step 3. Since R does not support minimization, we define another function that returns the negative result of log_density:
min_to_max <- function(l){
return(-log_density(sample, lambda))
}
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max, p=20)
# Step 3. Since R does not support minimization, we define another function that returns the negative result of log_density:
min_to_max <- function(lambda){
return(-log_density(sample, lambda))
}
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max, p=20)
View(estimation)
estimation$estimate
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max, p=5)
estimation$estimate
# Step 1. Simulate a poisson distribution:
sample <- rpois(10000, 20.5)
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max, p=5)
estimation$estimate
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max, p=10)
estimation$estimate
# Step 1. Simulate a poisson distribution:
sample <- rpois(100000, 20.5)
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max, p=10)
estimation$estimate
plot(sample)
plot(density(sample))
sample <- rpois(1000000, my_lambda)
plot(density(sample))
sample <- rpois(10, my_lambda)
# Step 1. Simulate a poisson distribution:
my_lambda=20
size=10
sample <- rpois(size, my_lambda)
plot(density(sample), main=paste("Sample size:",size))
# Step 1. Simulate a poisson distribution:
my_lambda=20
size=1000
sample <- rpois(size, my_lambda)
plot(density(sample), main=paste("Sample size:",size))
# EXTRA. To check how the estimation performs with other sample sizes:
size_range <- c(10, 50, 200, 500, 1000, 10000)
estimations <- c()
difference <- c()
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
append(estimations, current_est)
append(difference, (my_lambda-current_est))
}
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
print(current_est)
#append(estimations, current_est)
append(difference, (my_lambda-current_est))
}
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
print(current_est)
estimations <- append(estimations, current_est)
append(difference, (my_lambda-current_est))
}
# EXTRA. To check how the estimation performs with other sample sizes:
size_range <- c(10, 50, 200, 500, 1000, 10000)
estimations <- c()
difference <- c()
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
print(current_est)
estimations <- append(estimations, current_est)
difference <- append(difference, (my_lambda-current_est))
}
results <- as.data.frame(cbind(size_range, estimations, difference))
View(results)
plot(resutls)
plot(results)
plot(results$size_range, results[,2:3])
plot(results$size_range, results[,2])
# EXTRA. To check how the estimation performs with other sample sizes:
size_range <- c(10, 100, 1000, 10000, 100000, 1000000)
estimations <- c()
difference <- c()
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
estimations <- append(estimations, current_est)
difference <- append(difference, (my_lambda-current_est))
}
results <- as.data.frame(cbind(size_range, estimations, difference))
plot(results$size_range, results[,2])
plot(results$size_range, results[,2], log="x")
results <- as.data.frame(cbind(size_range, estimations, difference))
plot(results$size_range, results$estimations, log="x", ylab="Estimation", xlab="Sample size")
plot(results$size_range, results$difference, log="x", ylab="Estimation error", xlab="Sample size")
# EXTRA. To check how the estimation performs with other sample sizes:
size_range <- c(10, 100, 1000, 10000, 100000, 1000000, 10000000)
estimations <- c()
difference <- c()
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
estimations <- append(estimations, current_est)
difference <- append(difference, (my_lambda-current_est))
}
results <- as.data.frame(cbind(size_range, estimations, difference))
plot(results$size_range, results$estimations, log="x", ylab="Estimation", xlab="Sample size")
plot(results$size_range, results$difference, log="x", ylab="Estimation error", xlab="Sample size")
# EXTRA. To check how the estimation performs with other sample sizes:
size_range <- c(10, 100, 1000, 10000, 100000, 1000000, 10000000)
estimations <- c()
difference <- c()
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
estimations <- append(estimations, current_est)
difference <- append(difference, (my_lambda-current_est))
}
results <- as.data.frame(cbind(size_range, estimations, difference))
plot(results$size_range, results$estimations, log="x", ylab="Estimation", xlab="Sample size")
plot(results$size_range, results$difference, log="x", ylab="Estimation error", xlab="Sample size")
# EXTRA. To check how the estimation performs with other sample sizes:
size_range <- c(10, 100, 1000, 10000, 100000, 1000000)
estimations <- c()
difference <- c()
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
estimations <- append(estimations, current_est)
difference <- append(difference, (my_lambda-current_est))
}
results <- as.data.frame(cbind(size_range, estimations, difference))
plot(results$size_range, results$estimations, log="x", ylab="Estimation", xlab="Sample size")
plot(results$size_range, results$difference, log="x", ylab="Estimation error", xlab="Sample size")
# EXTRA. To check how the estimation performs with other sample sizes:
size_range <- c(10, 100, 1000, 10000, 100000, 1000000, 10000000)
estimations <- c()
difference <- c()
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
estimations <- append(estimations, current_est)
difference <- append(difference, (my_lambda-current_est))
}
results <- as.data.frame(cbind(size_range, estimations, difference))
plot(results$size_range, results$estimations, log="x", ylab="Estimation", xlab="Sample size")
plot(results$size_range, results$difference, log="x", ylab="Estimation error", xlab="Sample size")
plot(results$size_range, results$estimations, log="x", main="Estimation", xlab="Sample size")
abline(h=my_lambda)
plot(results$size_range, results$difference, log="x", main="Estimation error", xlab="Sample size")
abline(h=0)
plot(results$size_range, results$estimations, log="x", main="Estimation", xlab="Sample size", xaxp=results$size_range)
# Step 1. Simulate a poisson distribution:
my_lambda=20
size=100
sample <- rpois(size, my_lambda)
plot(density(sample), main=paste("Sample size:",size))
# Step 2. Define a function that computes the probability of the data belonging to a poisson distribution of a given lambda:
log_density <- function(data, lambda){
log_d <- dpois(data, lambda=lambda, log=TRUE)  # Stores the probability of all data points in a vector
return(sum(log_d))  # Returns the sum of such vector
}
abline(v=my_lambda)
# Step 2. Define a function that computes the probability of the data belonging to a poisson distribution of a given lambda:
log_density <- function(data, lambda){
log_d <- dpois(data, lambda=lambda, log=TRUE)  # Stores the probability of all data points in a vector
return(sum(log_d))  # Returns the sum of such vector
}
# Step 3. Since R does not support minimization, we define another function that returns the negative result of log_density:
min_to_max <- function(lambda){
return(-log_density(sample, lambda))
}
# Step 4. Maximize the probability using nlm on min_to_max, which eventually maximizes log_density.
estimation <- nlm(min_to_max, p=10)
estimation$estimate
abline(v=estimation$estimate, col="red")
abline(v=my_lambda, col="cyan")
# EXTRA. To check how the estimation performs with other sample sizes:
size_range <- c(10, 100, 1000, 10000, 100000, 1000000, 10000000)
estimations <- c()
difference <- c()
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
estimations <- append(estimations, current_est)
difference <- append(difference, (my_lambda-current_est))
}
results <- as.data.frame(cbind(size_range, estimations, difference))
plot(results$size_range, results$estimations, log="x", main="Estimation", xlab="Sample size", xaxp=results$size_range)
plot(results$size_range, results$estimations, log="x", main="Estimation", xlab="Sample size", xaxp=c(results$size_range))
plot(results$size_range, results$estimations, log="x", main="Estimation", xlab="Sample size", xaxp=c(10,10000000,7))
plot(results$size_range, results$estimations, log="x", main="Estimation", xlab="Sample size")
abline(h=my_lambda, col="cyan")
plot(results$size_range, results$difference, log="x", main="Estimation error", xlab="Sample size", xaxp=results$size_range)
abline(h=0, col="cyan")
plot(results$size_range, results$difference, log="x", main="Estimation error", xlab="Sample size")
abline(h=0, col="cyan")
results <- as.data.frame(cbind(size_range, estimations, difference))
plot(results$size_range, results$estimations, log="x", main="Estimation", xlab="Sample size", ylab="Estimate")
abline(h=my_lambda, col="cyan")
plot(results$size_range, results$difference, log="x", main="Estimation error", xlab="Sample size", ylab="Difference")
abline(h=0, col="cyan")
source('~/github/masters/module_ii/bayesian_inference/assignment.R')
my_lambda=20
size=100
sample <- rpois(size, my_lambda)
plot(density(sample), main=paste("Sample size:",size))
abline(v=my_lambda, col="cyan")
log_density <- function(data, lambda){
log_d <- dpois(data, lambda=lambda, log=TRUE)  # Stores the probability of all data points in a vector
return(sum(log_d))  # Returns the sum of such vector
}
min_to_max <- function(lambda){
return(-log_density(sample, lambda))
}
estimation <- nlm(min_to_max, p=10)
estimation$estimate
abline(v=estimation$estimate, col="red")
estimation <- nlm(min_to_max, p=10)
estimation$estimate
plot(density(sample), main=paste("Sample size:",size))
abline(v=my_lambda, col="cyan")
abline(v=estimation$estimate, col="red")
size_range <- c(10, 100, 1000, 10000, 100000, 1000000, 10000000)
estimations <- c()
difference <- c()
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
estimations <- append(estimations, current_est)
difference <- append(difference, (my_lambda-current_est))
}
results <- as.data.frame(cbind(size_range, estimations, difference))
plot(results$size_range, results$estimations, log="x", main="Estimation", xlab="Sample size", ylab="Estimate")
abline(h=my_lambda, col="cyan")
plot(results$size_range, results$difference, log="x", main="Estimation error", xlab="Sample size", ylab="Difference")
abline(h=0, col="cyan")
my_lambda=20
size=100
sample <- rpois(size, my_lambda)
log_density <- function(data, lambda){
log_d <- dpois(data, lambda=lambda, log=TRUE)  # Stores the probability of all data points in a vector
return(sum(log_d))  # Returns the sum of such vector
}
min_to_max <- function(lambda){
return(-log_density(sample, lambda))
}
estimation <- nlm(min_to_max, p=10)
print(paste("The estimated lambda is", estimation$estimate))
plot(density(sample), main=paste("Sample size:",size))
abline(v=my_lambda, col="cyan")
abline(v=estimation$estimate, col="red")
size_range <- c(10, 100, 1000, 10000, 100000, 1000000, 10000000)
estimations <- c()
difference <- c()
for (s in size_range){
sample <- rpois(s, my_lambda)
current_est <- nlm(min_to_max, p=10)$estimate
estimations <- append(estimations, current_est)
difference <- append(difference, (my_lambda-current_est))
}
results <- as.data.frame(cbind(size_range, estimations, difference))
plot(results$size_range, results$estimations, log="x", main="Estimation", xlab="Sample size", ylab="Estimate")
abline(h=my_lambda, col="cyan")
plot(results$size_range, results$difference, log="x", main="Estimation error", xlab="Sample size", ylab="Difference")
abline(h=0, col="cyan")
setwd("~/github/masters/module_v/SMPT/slurm_ass")
results <- read.csv('results.csv')
results <- read.csv('./files/results.csv')
View(results)
results <- read.csv('./files/results.csv')
plot(results)
results <- read.csv('./files/results.csv')
plot(c(1:19), results)
results <- read.csv('./files/results.csv')
plot(c(1:19), results[,])
results <- read.csv('./files/results.csv', header=FALSE)
plot(results[1,],results[2:,])
results <- read.csv('./files/results.csv', header=FALSE)
plot(results[1,],results[2:nrow(results),])
results <- read.csv('./files/results.csv')
results
settings <- read.csv('./files/settings.csv')
settings`
settings <- read.csv('./files/settings.csv')
settings
View(results)
results <- read.csv('./files/results.csv')
results[,ncol(results)]
results <- read.csv('./files/results.csv')
results[,18:19]
results <- read.csv('./files/results.csv')
results[,19]
results <- read.csv('./files/results.csv')
matrix(results[,19], nrow=6)
